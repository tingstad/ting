#!/bin/sh

/usr/bin/env node - <<EOF
import * as assert from 'assert';

$(sed -n '/^\(async \)*function /,/^}/p' zip-extractor.html)

const file = [
0x50, 0x4b, 0x03, 0x04, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0xbd, 0x63, 0x63, 0x5b, 0x16, 0x35,
0x96, 0x31, 0x06, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x1c, 0x00, 0x67, 0x72,
0x65, 0x65, 0x74, 0x69, 0x6e, 0x67, 0x2e, 0x74, 0x78, 0x74, 0x55, 0x54, 0x09, 0x00, 0x03, 0x35,
0x92, 0x08, 0x69, 0x36, 0x92, 0x08, 0x69, 0x75, 0x78, 0x0b, 0x00, 0x01, 0x04, 0xf5, 0x01, 0x00,
0x00, 0x04, 0x14, 0x00, 0x00, 0x00, 0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x0a, 0x50, 0x4b, 0x01, 0x02,
0x1e, 0x03, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0xbd, 0x63, 0x63, 0x5b, 0x16, 0x35, 0x96, 0x31,
0x06, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00,
0x01, 0x00, 0x00, 0x00, 0xa4, 0x81, 0x00, 0x00, 0x00, 0x00, 0x67, 0x72, 0x65, 0x65, 0x74, 0x69,
0x6e, 0x67, 0x2e, 0x74, 0x78, 0x74, 0x55, 0x54, 0x05, 0x00, 0x03, 0x35, 0x92, 0x08, 0x69, 0x75,
0x78, 0x0b, 0x00, 0x01, 0x04, 0xf5, 0x01, 0x00, 0x00, 0x04, 0x14, 0x00, 0x00, 0x00, 0x50, 0x4b,
0x05, 0x06, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x52, 0x00, 0x00, 0x00, 0x4c, 0x00,
0x00, 0x00, 0x00, 0x00 ];

const littleEndian = true;
const decodeIBM437 = newIBM437decoder();

const centralDirPK0102 = [0x50, 0x4b, 0x01, 0x02];

let headers = getCentralDirectoryHeaders(new Uint8Array(
        file.slice(indexOf(file, centralDirPK0102))).buffer, 1);

assert.deepEqual(headers
    , [{
        "filename": 'greeting.txt',
        "compression": 0,
        "sizeUncompressed": 6,
        "sizeCompressed": 6,
        "offsetLocalHeader": 0,
        "filenameLength": 12,
        "extraFieldLength": 24,
        "lastModifiedDate": "2025-11-03",
    }]);

let fetcher = (start, end) => new Uint8Array(file.slice(start, end)).buffer;
let blob = await getEntry(fetcher, headers[0], file.length);
assert.equal(blob.type, 'text/plain;charset=utf-8');
assert.equal(await blob.text(), 'Hello\n');

assert.equal(parseDate(23395), '2025-11-03'); // 0x63 0x5b => 0x5b63
assert.equal(parseDate(0x4271), '2013-03-17');

assert.equal(decodeIBM437([ 0x61 ]), 'a');
assert.equal(decodeIBM437([ 0x41, 0x42, 0x43 ]), 'ABC');
assert.equal(decodeIBM437([ 0x01, 0x02, 0x03, 0x04, 0x05, 0x06 ]), '☺☻♥♦♣♠');
assert.equal(decodeIBM437([ 0x81, 0x82, 0x83, 0x84, 0x85, 0x86 ]), 'üéâäàå');

assert.deepEqual(structure([]), []);
assert.deepEqual(structure(['index.htm']), [{ name: 'index.htm' }]);
assert.deepEqual(structure(['foo/index.htm']),
    [{ name: 'foo', files: [{ name: 'index.htm' }] }]);
assert.deepEqual(structure(
    ['index.htm', 'foo/1.txt', 'foo/2.txt', 'foo/bar/3.txt', 'bar/4.txt']), [
    { name: 'index.htm' },
    { name: 'foo', files: [
        { name: '1.txt' },
        { name: '2.txt' },
        { name: 'bar', files: [
            { name: '3.txt' },
        ]},
    ]},
    { name: 'bar', files: [
        { name: '4.txt' },
    ]}]);
assert.deepEqual(structure(['foo/bar/index.htm']),
    [{ name: 'foo', files: [{ name: 'bar', files: [{ name: 'index.htm' }] }]}]);

assert.equal(human(0), '0 B');
assert.equal(human(2), '2 B');
assert.equal(human(20), '20 B');
assert.equal(human(900), '900 B');
assert.equal(human(1023), '1023 B');
assert.equal(human(1024), '1.0 K');
assert.equal(human(1536), '1.5 K');
assert.equal(human(2048), '2.0 K');
assert.equal(human(20480), '20 K');
assert.equal(human(4194304), '4.0 M');
assert.equal(human(41943040), '40 M');

+assert.equal(indexOf([], []), 0);
+assert.equal(indexOf([0x01], []), 0);
+assert.equal(indexOf([], [0x01]), -1);
+assert.equal(indexOf([0x01], [0x01]), 0);
+assert.equal(indexOf([0x01, 0x02], [0x01]), 0);
+assert.equal(indexOf([0x01, 0x02], [0x02]), 1);
+assert.equal(indexOf([0x01], [0x01, 0x02]), -1);
+assert.equal(indexOf([0x01, 0x02], [0x01, 0x02]), 0);
+assert.equal(indexOf([0x01, 0x02, 0x02], [0x02]), 1);
+assert.equal(indexOf([0x01, 0x01, 0x02], [0x01, 0x02]), 1);

assert.equal(lastIndexOf([], []), 0);
assert.equal(lastIndexOf([0x01], []), 0);
assert.equal(lastIndexOf([], [0x01]), -1);
assert.equal(lastIndexOf([0x01], [0x01]), 0);
assert.equal(lastIndexOf([0x01, 0x02], [0x01]), 0);
assert.equal(lastIndexOf([0x01, 0x02], [0x02]), 1);
assert.equal(lastIndexOf([0x01], [0x01, 0x02]), -1);
assert.equal(lastIndexOf([0x01, 0x02], [0x01, 0x02]), 0);
assert.equal(lastIndexOf([0x01, 0x02, 0x02], [0x02]), 2);
assert.equal(lastIndexOf([0x01, 0x01, 0x02], [0x01, 0x02]), 1);

process.exit(0);
EOF

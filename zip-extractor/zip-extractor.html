<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="author" content="Richard H. Tingstad">
    <link rel="icon" href="data:image/svg+xml,%3Csvg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22%3E%3Ctext%20y=%22.9em%22%20font-size=%2290%22%3EðŸ“%3C/text%3E%3C/svg%3E">
    <title>Zip Extractor</title>
    <style>
        #error { background-color: #FFCCCB; }
        @keyframes spin { to { transform: rotate(360deg); } }
    </style>
</head>
<body>

<h1>Zip Extractor <a style="text-decoration:none" target="_blank"
    href="https://github.com/tingstad/ting/tree/master/zip-extractor"
    >â“˜</a></h1>

<div id="error"></div>

<form id="form">
    <input type="text" required name="url" id="url" size="70"
        placeholder="URL to zip file"
        value="" />
    <input type="hidden" id="force" name="force" value="" />
    <input type="submit" id="submit" />
</form>

<div id="files"></div>

<script>

const littleEndian = true;
const gui = document.getElementById('files');
const localProxy = location.hostname === "localhost";

function init() {
    const url = queryParamUrl();
    if (url) {
        byId('url').value = url;
    }
    byId('force').value = '';

    window.addEventListener("popstate", update);

    byId('form').addEventListener('submit', (e) => {
        e.preventDefault();
        byId('force').value = '';
        submit();
    });

    if (localProxy) {
        const orig = window.fetch;
        window.fetch = function(url, opts) {
            const proxy =
                `http://localhost:8080/proxy/${encodeURIComponent(url)}`;
            return orig(proxy, opts);
        };
    }
}

function submit() {
    const urlValue = byId('url').value;
    if (urlValue != queryParamUrl()) {
        const fullUrl = new URL(location);
        fullUrl.searchParams.set("url", urlValue);
        history.pushState({}, "", fullUrl);
    }
    const error = byId('error');
    error.innerHTML = '';
    const container = el('div');
    gui.prepend(container);
    load(urlValue, container)
        .catch((err) => {
            gui.removeChild(container);
            error.innerHTML = '';
            const p = el('p');
            const lines = err.message.split('\n');
            lines.forEach((line, i) => {
                p.appendChild(document.createTextNode(line));
                if (i < lines.length-1)
                    p.appendChild(el('br'));
            });
            error.appendChild(p);
            if (err instanceof RangeError || err instanceof RangeCorsError) {
                error.appendChild(el('p',
                    'If you think range requests are supported, you can try'
                    + ' anyways, at the risk of downloading the whole file. '
                    , el('input', { "type": "button", "value": "Yes",
                        "click": (e) => {
                            byId('force').value = 'true';
                            setTimeout(submit);
                        }})
                    ));
            }
            if (err instanceof MaybeCorsError) {
                error.appendChild(el('p',
                    'To avoid CORS errors, try running ',
                    el('code', 'npx zip-extractor'),
                    ' from your local machine. ', el('a', {
                    "href": "https://github.com/tingstad/ting/blob/master/zip-extractor/README.md",
                    "target": "_blank" }, 'Readme'), '.'));
            }
        });
}

function update() {
    const url = queryParamUrl();
    if (url) {
        byId('url').value = url;
    }
    error.innerHTML = '';
    gui.innerHTML = "";
}

function queryParamUrl() {
    const urlParams = new URLSearchParams(location.search);
    return urlParams.get('url');
}

async function load(url, container) {

    const spinner = el('span', {
            "style": "display: inline-block;"
                   + "transform-origin: 50% 50%;"
                   + "animation: spin 2s linear infinite;"
            }, 'âŒ›');
    container.appendChild(spinner);

    const length = await getContentLength(url);
    if (!length) {
        throw new Error("No Content-Length found");
    }

    const endOfCentralDir = await getEndOfCentralDirectory(url, length);

    const centralDirCount= endOfCentralDir.getUint16( 8, littleEndian);
    const centralDirSize = endOfCentralDir.getUint32(12, littleEndian);
    const centralDirOffs = endOfCentralDir.getUint32(16, littleEndian);

    let resp = await fetch(url, { headers: {
        "Range": `bytes=${centralDirOffs}-${centralDirOffs+centralDirSize}`
    }});
    if (!resp.ok) {
        throw new Error("HTTP error: " + resp.status);
    }
    let buffer = await resp.arrayBuffer();
    const centralDirHeaders = getCentralDirectoryHeaders(buffer, centralDirCount);

    const table = el('table',
        el('tr',
            el('th', { "colspan": "6", "style": "text-align: left" },
                el('a', { "href": url }, url),
                    el('span', { "style": "font-weight: 400" },
                        " (" + human(length) + ")")
            )),
        el('tr',
            el('th', 'Filename'),
            el('th', 'Method'),
            el('th', 'Size'),
            el('th', 'Length'),
            el('th', 'Cmpr'),
            el('th', 'GET'),
        ));
    centralDirHeaders.forEach((header, i) => {

        const ratio = header.sizeUncompressed == 0 ? 0
            : 100 - Math.round(
                header.sizeCompressed * 100 / header.sizeUncompressed);
        table.appendChild(
            el('tr',
                el('td', header.filename),
                el('td', header.compression),
                el('td', human(header.sizeCompressed)),
                el('td', human(header.sizeUncompressed)),
                el('td', `${ratio}%`),
                el('td',
                    el('input', { "type": "button", "value": "â¤“",
                      "click": (e) => {
                        e.preventDefault();
                        const span = el('span', {
                                "style": "display: inline-block;"
                                       + "transform-origin: 50% 50%;"
                                       + "animation: spin 2s linear infinite;"
                                }, 'âŒ›');
                        e.target.replaceWith(span);
                        const entry = centralDirHeaders
                            .filter((it) => it.filename == header.filename)[0];
                        getEntry(url, entry, length)
                            .then((blob) => {
                                span.replaceWith(
                                    el('a', 'ðŸ’¾', { "target": "_blank",
                                        "href": URL.createObjectURL(blob) })
                                );
                            })
                            .catch((error) => {
                                span.replaceWith(
                                    el('span', 'ðŸ’€', {
                                        "title": error.toString() })
                                );
                            });
                    }})
                ),
            )
        );
        spinner.replaceWith(table);
    });
}

async function getEntry(url, entry, contentLength) {
   /*
   4.3.7  Local file header:

      local file header signature     4 bytes  (0x04034b50)
      version needed to extract       2 bytes
      general purpose bit flag        2 bytes
      compression method              2 bytes
      last mod file time              2 bytes
      last mod file date              2 bytes
      crc-32                          4 bytes
      compressed size                 4 bytes
      uncompressed size               4 bytes
      file name length                2 bytes
      extra field length              2 bytes

      file name (variable size)
      extra field (variable size)
    */

    let localHeaderLength = 30
        + entry.filenameLength
        + entry.extraFieldLength
        + 32; // add a buffer because local extraFieldLength may be larger

    const start = entry.offsetLocalHeader;
    const end = Math.min(contentLength - 1,
        start + localHeaderLength + entry.sizeCompressed);

    let resp = await fetch(url, {
        headers: { "Range": `bytes=${start}-${end}` }
    });
    if (!resp.ok) {
        throw new Error("HTTP error: " + resp.status);
    }
    let buffer = await resp.arrayBuffer();
    let data = new DataView(buffer);

    const compressionMeth = data.getUint16(8,  littleEndian);
    const lastModFileTime = data.getUint16(10, littleEndian);
    const lastModFileDate = data.getUint16(12, littleEndian);
    const filenameLength  = data.getUint16(26, littleEndian);
    const extraFldLength  = data.getUint16(28, littleEndian);

    let filename = new TextDecoder() // TODO: specify encoding
        .decode(buffer.slice(30, 30 + filenameLength));

    localHeaderLength = 30
        + filenameLength
        + extraFldLength;

    const fileData = new Blob([ buffer
        .slice(localHeaderLength, localHeaderLength + entry.sizeCompressed) ]);
    let blob;
    if (compressionMeth == 8) {
        const ds = new DecompressionStream("deflate-raw"); // Baseline 2023
        const decompressedStream = fileData.stream().pipeThrough(ds);
        blob = await new Response(decompressedStream)
            .blob();
    } else {
        blob = fileData;
    }
    const typeBlob = new Blob([blob], { type: mimeType(filename) });
    return typeBlob;
}

function mimeType(filename) {
    const ext = filename.substring(filename.lastIndexOf('.')+1).toLowerCase();
    switch (ext) {
        case 'jpg':
        case 'jpeg':
            return "image/jpeg";
        case 'apng':
        case 'png':
        case 'gif':
        case 'avif':
        case 'webp':
            return `image/${ext}`;
        case 'svg':
            return "image/svg+xml";
        case 'htm':
        case 'html':
            return "text/html";
        default:
            return "text/plain";
    }
}

async function getContentLength(url) {
    let resp;
    try {
        resp = await fetch(url, { method: "HEAD" });
    } catch (error) {
        const opts = { cause: error };
        if (!navigator.onLine)
            throw new Error("Internet connectivity issues?\n" + error, opts);
        else
            throw new MaybeCorsError(
                "Server doesn't exist, or Cross-Origin Request may be blocked"
                + " by restrictive or non-existing CORS header"
                + " 'Access-Control-Allow-Origin'.\n" + error, opts);
    }

    if (!resp.ok) {
      throw new Error("HTTP error: " + resp.status);
    }

    const isForced = !!byId('force').value;
    if (!isForced) {
        await checkAcceptRanges(url, resp.headers);
    }

    // TODO: check header content-type application/epub+zip, application/java-archive

    const length = resp.headers.get("content-length");
    if (length === null) {
        // TODO: smart scan from top using Range
        throw new Error("Content-Length header not found");
    }

    return parseInt(length, 10);
}

async function checkAcceptRanges(url, headers) {

    let acceptRanges = headers.get("Accept-Ranges");

    const noRangesError = new RangeError("Accept-Ranges header not found");
    const noBytesError = new RangeError("Accept-Ranges does not include 'bytes'");

    if (!acceptRanges && localProxy) {
        throw noRangesError;
    }
    if (!acceptRanges) {
        let okResp = null;
        try {
            const res = await fetch(
                `https://space.ting.st/proxy?url=${encodeURIComponent(url)}`,
                { method: "HEAD" });
            if (res.ok) okResp = res;
        } catch (proxyError) {}
        if (okResp) {
            acceptRanges = okResp.headers.get("Accept-Ranges");
        } else {
            throw new RangeCorsError("Accept-Ranges header is not set, or"
            + " hidden because of restrictive or non-existing CORS header"
            + " 'Access-Control-Expose-Headers'.");
        }
    }
    if (!acceptRanges) {
        throw noRangesError;
    }
    if (!acceptRanges.includes('bytes')) {
        throw noBytesError;
    }
}

function getCentralDirectoryHeaders(buffer, count) {
   /*
   4.3.12  Central directory structure:

      [central directory header 1]
      .
      .
      . 
      [central directory header n]
      [digital signature] 

      File header:

        central file header signature   4 bytes  (0x02014b50)
        version made by                 2 bytes
        version needed to extract       2 bytes
        general purpose bit flag        2 bytes
        compression method              2 bytes
        last mod file time              2 bytes
        last mod file date              2 bytes
        crc-32                          4 bytes
        compressed size                 4 bytes
        uncompressed size               4 bytes
        file name length                2 bytes
        extra field length              2 bytes
        file comment length             2 bytes
        disk number start               2 bytes
        internal file attributes        2 bytes
        external file attributes        4 bytes
        relative offset of local header 4 bytes

        file name (variable size)
        extra field (variable size)
        file comment (variable size)
    */
    const centralDir = new DataView(buffer);

    const headers = [];

    let off = 0;
    for (let i = 0; i < count; i++) {

        let compression = centralDir.getUint16(off + 10, littleEndian);
        let sizeComprsd = centralDir.getUint32(off + 20, littleEndian);
        let sizeUncompr = centralDir.getUint32(off + 24, littleEndian);
        let filenameLen = centralDir.getUint16(off + 28, littleEndian);
        let extraFldLen = centralDir.getUint16(off + 30, littleEndian);
        let fileCmntLen = centralDir.getUint16(off + 32, littleEndian);
        let offsetLocal = centralDir.getUint32(off + 42, littleEndian);

        let filename = new TextDecoder() // TODO: specify encoding
            .decode(buffer.slice(off + 46, off + 46 + filenameLen));

        headers.push({
            filename: filename,
            compression: compression,
            sizeUncompressed: sizeUncompr,
            sizeCompressed: sizeComprsd,
            offsetLocalHeader: offsetLocal,
            filenameLength: filenameLen,
            extraFieldLength: extraFldLen,
        });

        off += 46 + filenameLen + extraFldLen + fileCmntLen;
    }
    
    return headers;
}

async function getEndOfCentralDirectory(url, contentLength) {
    let start = contentLength - 1024;
    let end = contentLength - 1;
    let resp = await fetch(url, {
        headers: { "Range": `bytes=${start}-${end}` }
    });
    if (!resp.ok) {
        throw new Error("HTTP error: " + resp.status);
    }
    let buffer = await resp.arrayBuffer();

    const endDirPK0506 = [0x50, 0x4b, 0x05, 0x06];
    let idx = findBytes(buffer, endDirPK0506); // TODO: lastIndexOf

    if (idx < 0)
        throw new Error("End of central directory not found");
        // TODO: expand search

    return new DataView(buffer, idx);
}

function findBytes(buffer, pattern) {
    const bytes = new Uint8Array(buffer);
    const pat = new Uint8Array(pattern);
  
    for (let i = 0; i <= bytes.length - pat.length; i++) {
        let found = true;
        for (let j = 0; j < pat.length; j++) {
            if (bytes[i + j] !== pat[j]) {
                found = false;
                break;
            }
        }
        if (found) return i; // return first index
    }
    return -1;
}

function human(n) {
    const bytes = Number(n);
    if (bytes == 0) return "0 B";
    const k = 1024;
    const units = ["B", "K", "M", "G", "T", "P"];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    const size = bytes / Math.pow(k, i);
    const rounded = size >= 10
        ? Math.round(size)
        : size.toFixed(1);
    return rounded + " " + units[i];
}

function el(tag, ...args) {
    const e = document.createElement(tag);
    for (const arg of args) {
        if (arg instanceof Node) {
            e.appendChild(arg);
        } else if (["string", "number", "boolean"].includes(typeof arg)) {
            e.appendChild(document.createTextNode(arg));
        } else if (typeof arg === "object") {
            for (const [k, v] of Object.entries(arg)) {
                if (typeof v === "function") {
                    e.addEventListener(k, v);
                } else {
                    e.setAttribute(k, v);
                }
            }
        } else {
            throw new Error(`unsupported arg: ${typeof arg} ${arg}`);
        }
    }
    return e;
}

const byId = (id) => document.getElementById(id);

class MaybeCorsError extends Error { constructor(...args) { super(...args); }}
class RangeError extends Error { constructor(...args) { super(...args); }}
class RangeCorsError extends MaybeCorsError {
    constructor(...args) { super(...args); }}

init();
</script>

</body>
</html>


<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="author" content="Richard H. Tingstad">
    <link rel="icon" href="data:image/svg+xml,%3Csvg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22%3E%3Ctext%20y=%22.9em%22%20font-size=%2290%22%3E%F0%9F%93%81%0A%3C/text%3E%3C/svg%3E">
    <title>Zip Extractor</title>
    <style>
        @keyframes spin { to { transform: rotate(360deg); } }
    </style>
</head>
<body>

<h1>Zip Extractor <a style="text-decoration:none" target="_blank"
    href="https://github.com/tingstad/ting/tree/master/zip-extractor"
    >‚ìò</a></h1>

<div id="error" style="background-color: #FFCCCB;"></div>

<form id="form">
    <input type="text" required name="url" id="url" size="70"
        placeholder="URL to zip file"
        value="" />
    <input type="hidden" id="force" name="force" value="" />
    <input type="submit" id="submit" />
</form>

<div id="files"></div>

<script>

const littleEndian = true;
const gui = document.getElementById('files');
const localProxy = location.hostname === "localhost";

function init() {
    const url = queryParamUrl();
    if (url) {
        byId('url').value = url;
    }
    byId('force').value = '';

    window.addEventListener("popstate", update);

    byId('form').addEventListener('submit', (e) => {
        e.preventDefault();
        byId('force').value = '';
        submit();
    });

    if (localProxy) {
        const orig = window.fetch;
        window.fetch = function(url, opts) {
            const proxy =
                `http://localhost:8080/proxy/${encodeURIComponent(url)}`;
            return orig(proxy, opts);
        };
    }

    if (new URLSearchParams(location.search).get('autoload')) {
        submit();
    }
}

function submit() {
    const error = byId('error');
    error.innerHTML = '';
    const urlValue = byId('url').value;
    if (urlValue.toLowerCase().startsWith('http://')
        && location.protocol == 'https:'
    ) {
        const u = new URL(location.href);
        u.protocol = 'http:';
        u.searchParams.set('url', urlValue);
        u.searchParams.set('autoload', 'true');
        error.appendChild(el('p',
            'URL is http: so you must go to: ',
                el('a', { "href": u }, u.toString())));
        error.appendChild(el('p',
            'Or you can try running ',
            el('code', 'npx zip-extractor'),
            ' from your local machine. ', el('a', {
            "href": "https://github.com/tingstad/ting/blob/master/zip-extractor/README.md",
            "target": "_blank" }, 'Readme'), '.'));
        return;
    }
    if (urlValue != queryParamUrl()) {
        const fullUrl = new URL(location.href);
        fullUrl.searchParams.set("url", urlValue);
        history.pushState({}, "", fullUrl);
    }
    const container = el('div');
    gui.prepend(container);
    load(urlValue, container)
        .catch((err) => {
            gui.removeChild(container);
            error.innerHTML = '';
            const p = el('p');
            const lines = err.message.split('\n');
            lines.forEach((line, i) => {
                p.appendChild(document.createTextNode(line));
                if (i < lines.length-1)
                    p.appendChild(el('br'));
            });
            error.appendChild(p);
            if (err instanceof RangeError || err instanceof RangeCorsError) {
                error.appendChild(el('p',
                    'If you think range requests are supported, you can try'
                    + ' anyways, at the risk of downloading the whole file. '
                    , el('input', { "type": "button", "value": "Yes",
                        "click": (e) => {
                            byId('force').value = 'true';
                            setTimeout(submit);
                        }})
                    ));
            }
            if (err instanceof MaybeCorsError) {
                error.appendChild(el('p',
                    'To avoid CORS errors, try running ',
                    el('code', 'npx zip-extractor'),
                    ' from your local machine. ', el('a', {
                    "href": "https://github.com/tingstad/ting/blob/master/zip-extractor/README.md",
                    "target": "_blank" }, 'Readme'), '.'));
            }
        });
}

function update() {
    const url = queryParamUrl();
    if (url) {
        byId('url').value = url;
    }
    error.innerHTML = '';
    gui.innerHTML = "";
}

function queryParamUrl() {
    const urlParams = new URLSearchParams(location.search);
    return urlParams.get('url');
}

async function load(url, container) {

    const spinner = el('span', {
            "style": "display: inline-block;"
                   + "transform-origin: 50% 50%;"
                   + "animation: spin 2s linear infinite;"
            }, '‚åõ');
    container.appendChild(spinner);

    const length = await getContentLength(url);
    if (!length && !byId('force').value) {
        throw new Error("No Content-Length found");
    }

    const result = await getEndOfCentralDirectory(url, length);
    const { endOfCentralDir } = result;

    const centralDirCount= endOfCentralDir.getUint16( 8, littleEndian);
    const centralDirSize = endOfCentralDir.getUint32(12, littleEndian);
    const centralDirOffs = endOfCentralDir.getUint32(16, littleEndian);
    const fileCommentLen = endOfCentralDir.getUint16(20, littleEndian);
    const fileComment    = fileCommentLen == 0 ? "" :
        new TextDecoder().decode(result.buffer.slice(
            endOfCentralDir.byteOffset + 22,
            endOfCentralDir.byteOffset + 22 + fileCommentLen));

    // Maybe we got the whole file if Range is not supported
    const hasAllData = !result.response.headers.has('content-range')
        && result.buffer.byteLength > centralDirOffs + centralDirSize;

    let fetcher = async (start, end) => {
        let resp = await fetch(url, {
            headers: { "Range": `bytes=${start}-${end}` }
        });
        if (!resp.ok) {
            throw new Error("HTTP error: " + resp.status);
        }
        return await resp.arrayBuffer();
    };
    if (hasAllData)
        fetcher = (start, end) => Promise.resolve(result.buffer.slice(start, end));

    const buffer = await fetcher(centralDirOffs, centralDirOffs + centralDirSize);

    const centralDirHeaders = getCentralDirectoryHeaders(buffer, centralDirCount)
        .filter(skipDirectories);

    const table = el('table',
        el('tr',
            el('th', 'Filename'),
            el('th', 'Method'),
            el('th', 'Date'),
            el('th', 'Size'),
            el('th', 'Length'),
            el('th', 'Cmpr'),
            el('th', 'GET'),
        ));
    centralDirHeaders.forEach((header, i) => {

        const ratio = header.sizeUncompressed == 0 ? 0
            : 100 - Math.round(
                header.sizeCompressed * 100 / header.sizeUncompressed);
        table.appendChild(
            el('tr',
                el('td', header.filename,
                    {...(header.fileComment && {"title": header.fileComment})}),
                el('td', header.compression,
                    { "title": methodDescription(header.compression) }),
                el('td', header.lastModifiedDate),
                el('td', human(header.sizeCompressed),
                    { "title": header.sizeCompressed }),
                el('td', human(header.sizeUncompressed),
                    { "title": header.sizeUncompressed }),
                el('td', `${ratio}%`),
                el('td',
                    el('input', { "type": "button", "value": "‚§ì",
                      "click": (e) => {
                        e.preventDefault();
                        const span = el('span', {
                                "style": "display: inline-block;"
                                       + "transform-origin: 50% 50%;"
                                       + "animation: spin 2s linear infinite;"
                                }, '‚åõ');
                        e.target.replaceWith(span);
                        const entry = centralDirHeaders
                            .filter((it) => it.filename === header.filename)[0];
                        getEntry(fetcher, entry, length)
                            .then((blob) => {
                                span.replaceWith(
                                    el('a', 'üíæ', { "target": "_blank",
                                        "title": blob.type,
                                        "href": URL.createObjectURL(blob) })
                                );
                            })
                            .catch((error) => {
                                span.replaceWith(
                                    el('span', 'üíÄ', {
                                        "title": error.toString() })
                                );
                            });
                    }})
                ),
            )
        );
    });
    spinner.replaceWith(
        el('details', { "open": "true" },
            el('summary',
                el('a', { "href": url, "target": "_blank",
                    "style": "font-weight: 600" }, url),
                el('span', { "style": "font-weight: 400" },
                    " (" + human(length) + ")"),
            ),
            (fileComment ? el('pre', fileComment) : ""),
            table,
        )
    );
}

async function getEntry(fetcher, entry, contentLength) {
   /*
   4.3.7  Local file header:

      local file header signature     4 bytes  (0x04034b50)
      version needed to extract       2 bytes
      general purpose bit flag        2 bytes
      compression method              2 bytes
      last mod file time              2 bytes
      last mod file date              2 bytes
      crc-32                          4 bytes
      compressed size                 4 bytes
      uncompressed size               4 bytes
      file name length                2 bytes
      extra field length              2 bytes

      file name (variable size)
      extra field (variable size)
    */

    let localHeaderLength = 30
        + entry.filenameLength
        + entry.extraFieldLength
        + 32; // add a buffer because local extraFieldLength may be larger

    const start = entry.offsetLocalHeader;
    const end = Math.min(contentLength - 1,
        start + localHeaderLength + entry.sizeCompressed);

    let buffer = await fetcher(start, end);
    let data = new DataView(buffer);

    const generalPurpFlag = data.getUint16(8,  littleEndian);
    const compressionMeth = data.getUint16(8,  littleEndian);
    const lastModFileTime = data.getUint16(10, littleEndian);
    const lastModFileDate = data.getUint16(12, littleEndian);
    const filenameLength  = data.getUint16(26, littleEndian);
    const extraFldLength  = data.getUint16(28, littleEndian);

    const filenameBuffer = buffer.slice(30, 30 + filenameLength);

    const filename = decodeFilename(generalPurpFlag, filenameBuffer);

    localHeaderLength = 30
        + filenameLength
        + extraFldLength;

    const fileData = new Blob([ buffer
        .slice(localHeaderLength, localHeaderLength + entry.sizeCompressed) ]);
    let blob;
    if (compressionMeth == 8) {
        const ds = new DecompressionStream("deflate-raw"); // Baseline 2023
        const decompressedStream = fileData.stream().pipeThrough(ds);
        blob = await new Response(decompressedStream)
            .blob();
    } else {
        blob = fileData;
    }

    let mimetype = mimeType(filename);
    if (mimetype.startsWith('text/')) {
        const bytes = await blob.bytes();
        let validUTF8 = bytes.indexOf(0x00) === -1;
        if (validUTF8) {
            try { new TextDecoder("utf-8", { fatal: true }).decode(bytes);
            } catch { validUTF8 = false; }
        }
        mimetype = `${mimetype};charset=${validUTF8 ? "utf-8" : "iso-8859-1"}`;
    }

    return new Blob([blob], { type: mimetype });
}

function mimeType(filename) {
    const ext = filename.substring(filename.lastIndexOf('.')+1).toLowerCase();
    switch (ext) {
        case 'jpg':
        case 'jpeg':
            return "image/jpeg";
        case 'apng':
        case 'png':
        case 'gif':
        case 'avif':
        case 'webp':
            return `image/${ext}`;
        case 'svg':
            return "image/svg+xml";
        case 'htm':
        case 'html':
            return "text/html";
        default:
            return "text/plain";
    }
}

async function getContentLength(url) {
    let resp;
    try {
        resp = await fetch(url, { method: "HEAD" });
    } catch (error) {
        const opts = { cause: error };
        if (!navigator.onLine)
            throw new Error("Internet connectivity issues?\n" + error, opts);
        else
            throw new MaybeCorsError(
                "Server doesn't exist, or Cross-Origin Request may be blocked"
                + " by restrictive or non-existing CORS header"
                + " 'Access-Control-Allow-Origin'.\n" + error, opts);
    }

    if (!resp.ok) {
      throw new Error("HTTP error: " + resp.status);
    }

    const isForced = !!byId('force').value;
    if (!isForced) {
        await checkAcceptRanges(url, resp.headers);
    }

    // TODO: check header content-type application/epub+zip, application/java-archive

    const length = resp.headers.get("content-length");
    if (length === null) {
        if (isForced) return 0;
        throw new Error("Content-Length header not found");
        // TODO: smart scan from top using Range if !isForced (accept-ranges ok)
    }

    return parseInt(length, 10);
}

async function checkAcceptRanges(url, headers) {

    let acceptRanges = headers.get("Accept-Ranges");

    const noRangesError = new RangeError("Accept-Ranges header not found");
    const noBytesError = new RangeError("Accept-Ranges does not include 'bytes'");

    if (!acceptRanges && localProxy) {
        throw noRangesError;
    }
    if (!acceptRanges) {
        let okResp = null;
        try {
            const res = await fetch(
                `https://space.ting.st/proxy?url=${encodeURIComponent(url)}`,
                { method: "HEAD" });
            if (res.ok) okResp = res;
        } catch (proxyError) {}
        if (okResp) {
            acceptRanges = okResp.headers.get("Accept-Ranges");
        } else {
            throw new RangeCorsError("Accept-Ranges header is not set, or"
            + " hidden because of restrictive or non-existing CORS header"
            + " 'Access-Control-Expose-Headers'.");
        }
    }
    if (!acceptRanges) {
        throw noRangesError;
    }
    if (!acceptRanges.includes('bytes')) {
        throw noBytesError;
    }
}

function getCentralDirectoryHeaders(buffer, count) {
   /*
   4.3.12  Central directory structure:

      [central directory header 1]
      .
      .
      . 
      [central directory header n]
      [digital signature] 

      File header:

        central file header signature   4 bytes  (0x02014b50)
        version made by                 2 bytes
        version needed to extract       2 bytes
        general purpose bit flag        2 bytes
        compression method              2 bytes
        last mod file time              2 bytes
        last mod file date              2 bytes
        crc-32                          4 bytes
        compressed size                 4 bytes
        uncompressed size               4 bytes
        file name length                2 bytes
        extra field length              2 bytes
        file comment length             2 bytes
        disk number start               2 bytes
        internal file attributes        2 bytes
        external file attributes        4 bytes
        relative offset of local header 4 bytes

        file name (variable size)
        extra field (variable size)
        file comment (variable size)
    */
    const centralDir = new DataView(buffer);

    const headers = [];

    let off = 0;
    for (let i = 0; i < count; i++) {

        const generalPurp = centralDir.getUint16(off +  8, littleEndian);
        const compression = centralDir.getUint16(off + 10, littleEndian);
        const lastModDate = centralDir.getUint16(off + 14, littleEndian);
        const sizeComprsd = centralDir.getUint32(off + 20, littleEndian);
        const sizeUncompr = centralDir.getUint32(off + 24, littleEndian);
        const filenameLen = centralDir.getUint16(off + 28, littleEndian);
        const extraFldLen = centralDir.getUint16(off + 30, littleEndian);
        const fileCmntLen = centralDir.getUint16(off + 32, littleEndian);
        const offsetLocal = centralDir.getUint32(off + 42, littleEndian);

        const filenameBuffer = buffer.slice(off + 46, off + 46 + filenameLen);

        const filename = decodeFilename(generalPurp, filenameBuffer);

        const fileComment = fileCmntLen ? decodeFilename(generalPurp,
            buffer.slice(
                off + 46 + filenameLen + extraFldLen,
                off + 46 + filenameLen + extraFldLen + fileCmntLen)) : '';

        headers.push({
            filename: filename,
            compression: compression,
            sizeUncompressed: sizeUncompr,
            sizeCompressed: sizeComprsd,
            offsetLocalHeader: offsetLocal,
            filenameLength: filenameLen,
            extraFieldLength: extraFldLen,
            lastModifiedDate: parseDate(lastModDate),
            fileComment: fileComment,
        });

        off += 46 + filenameLen + extraFldLen + fileCmntLen;
    }
    
    return headers;
}

async function getEndOfCentralDirectory(url, contentLength) {
    let start = contentLength - 1024;
    let end = contentLength - 1;
    let headers = {};
    if (contentLength) { // can be 0 if force=true
        headers.Range = `bytes=${start}-${end}`;
    }
    let resp = await fetch(url, { headers });
    if (!resp.ok) {
        throw new Error("HTTP error: " + resp.status);
    }
    let buffer = await resp.arrayBuffer();

    const endDirPK0506 = [0x50, 0x4b, 0x05, 0x06];
    let idx = lastIndexOf(buffer, endDirPK0506);

    if (idx < 0)
        throw new Error("End of central directory not found");
        // TODO: expand search

    return {
        endOfCentralDir: new DataView(buffer, idx),
        response: resp,
        buffer: buffer,
    }
}

function skipDirectories(it, i, headers) {
    return !(
        it.sizeUncompressed === 0
        && it.filename.endsWith('/')
    );
}

function parseDate(date) {
    /*
    Bits    Description
    0-4     Day of the month (1‚Äì31)
    5-8     Month (1 = January, 2 = February, and so on)
    9-15    Year offset from 1980 (add 1980 to get actual year)
    https://learn.microsoft.com/nb-no/windows/win32/api/winbase/nf-winbase-dosdatetimetofiletime
    */

    const day  = (date       & 0x1F); // 0x1F = 1 1111
    const mon  = (date >> 5) & 0x0F;  // 0x0F = 1111
    const yrs  = (date >> 9) & 0x7F;  // 0x7F = 0111 1111

    const yyyy = 1980 + yrs;
    const mm   = String(mon).padStart(2, "0");
    const dd   = String(day).padStart(2, "0");

    return `${yyyy}-${mm}-${dd}`;
}

function decodeFilename(generalPurposeBitFlag, filenameBuffer) {
/*
D.1 The ZIP format has historically supported only the original IBM PC character
encoding set, commonly referred to as IBM Code Page 437.

D.2 If general purpose bit 11 is unset, the file name and comment SHOULD conform
to the original ZIP character encoding.  If general purpose bit 11 is set, the
filename and comment MUST support The Unicode Standard,
*/

        const UTF8 = 0x0800; // 1000 0000 0000

        const isUTF8 = (generalPurposeBitFlag & UTF8);

        // Even though the spec says IBM CP 437, others may be used in practice
        // We assume UTF-8 or IBM CP 437 for now
        // TODO: support/detect others?
        return isUTF8
            ? new TextDecoder("utf-8").decode(filenameBuffer)
            : decodeIBM437(new Uint8Array(filenameBuffer));
}

const decodeIBM437 = newIBM437decoder();

function newIBM437decoder() {
    return decoder(tableCP437());
}

function decoder(table) {
    return function(bytes) {
        return Array.from(bytes, b => table[b]).join('');
    }
}

function methodDescription(method) {
    //pkware.cachefly.net/webdocs/APPNOTE/APPNOTE-6.3.9.TXT
    const spec = `4.4.5 compression method: (2 bytes)

        0 - The file is stored (no compression)
        1 - The file is Shrunk
        2 - The file is Reduced with compression factor 1
        3 - The file is Reduced with compression factor 2
        4 - The file is Reduced with compression factor 3
        5 - The file is Reduced with compression factor 4
        6 - The file is Imploded
        7 - Reserved for Tokenizing compression algorithm
        8 - The file is Deflated
        9 - Enhanced Deflating using Deflate64(tm)
       10 - PKWARE Data Compression Library Imploding (old IBM TERSE)
       11 - Reserved by PKWARE
       12 - File is compressed using BZIP2 algorithm
       13 - Reserved by PKWARE
       14 - LZMA
       15 - Reserved by PKWARE
       16 - IBM z/OS CMPSC Compression
       17 - Reserved by PKWARE
       18 - File is compressed using IBM TERSE (new)
       19 - IBM LZ77 z Architecture 
       20 - deprecated (use method 93 for zstd)
       93 - Zstandard (zstd) Compression 
       94 - MP3 Compression 
       95 - XZ Compression 
       96 - JPEG variant
       97 - WavPack compressed data
       98 - PPMd version I, Rev 1
       99 - AE-x encryption marker (see APPENDIX E)

       4.4.5.1 Methods 1-6 are legacy algorithms and are no longer
       recommended for use when compressing files.`;

    for (let line of spec.split('\n')) {
        let s = line.trim();
        if (s.startsWith(`${method} - `))
            return s;
    }
    return '';
}

function indexOf(buffer, pattern) {
    const bytes = new Uint8Array(buffer);
    const pat = new Uint8Array(pattern);

    if (!pat.length) return 0;

    for (let i = 0; i <= bytes.length - pat.length; i++) {
        let found = true;
        for (let j = 0; j < pat.length; j++) {
            if (bytes[i + j] !== pat[j]) {
                found = false;
                break;
            }
        }
        if (found) return i; // return first index
    }
    return -1;
}

function lastIndexOf(buffer, pattern) {
    const bytes = new Uint8Array(buffer);
    const pat = new Uint8Array(pattern);

    if (!pat.length) return 0;

    for (let i = bytes.length - pat.length; i >= 0; i--) {
        let found = true;
        for (let j = 0; j < pat.length; j++) {
            if (bytes[i + j] !== pat[j]) {
                found = false;
                break;
            }
        }
        if (found) return i; // return first index
    }
    return -1;
}

function human(n) {
    const bytes = Number(n);
    const k = 1024;
    const units = ["B", "K", "M", "G", "T", "P"];
    if (bytes < k) return `${bytes} ${units[0]}`;
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    const size = bytes / Math.pow(k, i);
    const rounded = size >= 10
        ? Math.round(size)
        : size.toFixed(1);
    return rounded + " " + units[i];
}

function el(tag, ...args) {
    const e = document.createElement(tag);
    for (const arg of args) {
        if (arg instanceof Node) {
            e.appendChild(arg);
        } else if (["string", "number", "boolean"].includes(typeof arg)) {
            e.appendChild(document.createTextNode(arg));
        } else if (typeof arg === "object") {
            for (const [k, v] of Object.entries(arg)) {
                if (typeof v === "function") {
                    e.addEventListener(k, v);
                } else {
                    e.setAttribute(k, v);
                }
            }
        } else {
            throw new Error(`unsupported arg: ${typeof arg} ${arg}`);
        }
    }
    return e;
}

const byId = (id) => document.getElementById(id);

class MaybeCorsError extends Error { constructor(...args) { super(...args); }}
class RangeError extends Error { constructor(...args) { super(...args); }}
class RangeCorsError extends MaybeCorsError {
    constructor(...args) { super(...args); }}

function tableCP437() {  return [  // https://mw.rat.bz/cp437map/
'\u2007',  // ‚Äá FIGURE SPACE
'\u263A',  // ‚ò∫ WHITE SMILING FACE
'\u263B',  // ‚òª BLACK SMILING FACE
'\u2665',  // ‚ô• BLACK HEART SUIT
'\u2666',  // ‚ô¶ BLACK DIAMOND SUIT
'\u2663',  // ‚ô£ BLACK CLUB SUIT
'\u2660',  // ‚ô† BLACK SPADE SUIT
'\u2022',  // ‚Ä¢ BULLET
'\u25D8',  // ‚óò INVERSE BULLET
'\u25CB',  // ‚óã WHITE CIRCLE
'\u25D9',  // ‚óô INVERSE WHITE CIRCLE
'\u2642',  // ‚ôÇ MALE SIGN
'\u2640',  // ‚ôÄ FEMALE SIGN
'\u266A',  // ‚ô™ EIGHTH NOTE              INCORRECT - BUT WIDELY SUPPORTED
'\u266C',  // ‚ô¨ BEAMED SIXTEENTH NOTES       CORRECT
'\u263C',  // ‚òº WHITE SUN WITH RAYS
'\u25B6',  // ‚ñ∂ BLACK RIGHT-POINTING TRIANGLE    CORRECT - BUT NOT WIDELY SUPPORTED
'\u25C0',  // ‚óÄ BLACK LEFT-POINTING TRIANGLE     CORRECT - BUT NOT WIDELY SUPPORTED
'\u2195',  // ‚Üï UP DOWN ARROW
'\u203C',  // ‚Äº DOUBLE EXCLAMATION MARK
'\u00B6',  // ¬∂ PILCROW SIGN
'\u00A7',  // ¬ß SECTION SIGN
'\u25AC',  // ‚ñ¨ BLACK RECTANGLE
'\u21A8',  // ‚Ü® UP DOWN ARROW WITH BASE
'\u2191',  // ‚Üë UPWARDS ARROW
'\u2193',  // ‚Üì DOWNWARDS ARROW
'\u2192',  // ‚Üí RIGHTWARDS ARROW
'\u2190',  // ‚Üê LEFTWARDS ARROW
'\u2319',  // ‚åô TURNED NOT SIGN          CORRECT
'\u2194',  // ‚Üî LEFT RIGHT ARROW
'\u25B2',  // ‚ñ≤ BLACK UP-POINTING TRIANGLE
'\u25BC',  // ‚ñº BLACK DOWN-POINTING TRIANGLE
'\u0020',  //   SPACE
'\u0021',  // ! EXCLAMATION MARK
'\u0022',  // " QUOTATION MARK
'\u0023',  // # NUMBER SIGN
'\u0024',  // $ DOLLAR SIGN
'\u0025',  // % PERCENT SIGN
'\u0026',  // & AMPERSAND
'\u2019',  // ‚Äô RIGHT SINGLE QUOTATION MARK      CORRECT
'\u0028',  // ( LEFT PARENTHESIS
'\u0029',  // ) RIGHT PARENTHESIS
'\u002A',  // * ASTERISK
'\u002B',  // + PLUS SIGN
'\u002C',  // , COMMA
'\u002D',  // - HYPHEN-MINUS
'\u002E',  // . FULL STOP
'\u002F',  // / SOLIDUS
'\u0030',  // 0 DIGIT ZERO
'\u0031',  // 1 DIGIT ONE
'\u0032',  // 2 DIGIT TWO
'\u0033',  // 3 DIGIT THREE
'\u0034',  // 4 DIGIT FOUR
'\u0035',  // 5 DIGIT FIVE
'\u0036',  // 6 DIGIT SIX
'\u0037',  // 7 DIGIT SEVEN
'\u0038',  // 8 DIGIT EIGHT
'\u0039',  // 9 DIGIT NINE
'\u003A',  // : COLON
'\u003B',  // ; SEMICOLON
'\u003C',  // < LESS-THAN SIGN
'\u003D',  // = EQUALS SIGN
'\u003E',  // > GREATER-THAN SIGN
'\u003F',  // ? QUESTION MARK
'\u0040',  // @ COMMERCIAL AT
'\u0041',  // A LATIN CAPITAL LETTER A
'\u0042',  // B LATIN CAPITAL LETTER B
'\u0043',  // C LATIN CAPITAL LETTER C
'\u0044',  // D LATIN CAPITAL LETTER D
'\u0045',  // E LATIN CAPITAL LETTER E
'\u0046',  // F LATIN CAPITAL LETTER F
'\u0047',  // G LATIN CAPITAL LETTER G
'\u0048',  // H LATIN CAPITAL LETTER H
'\u0049',  // I LATIN CAPITAL LETTER I
'\u004A',  // J LATIN CAPITAL LETTER J
'\u004B',  // K LATIN CAPITAL LETTER K
'\u004C',  // L LATIN CAPITAL LETTER L
'\u004D',  // M LATIN CAPITAL LETTER M
'\u004E',  // N LATIN CAPITAL LETTER N
'\u004F',  // O LATIN CAPITAL LETTER O
'\u0050',  // P LATIN CAPITAL LETTER P
'\u0051',  // Q LATIN CAPITAL LETTER Q
'\u0052',  // R LATIN CAPITAL LETTER R
'\u0053',  // S LATIN CAPITAL LETTER S
'\u0054',  // T LATIN CAPITAL LETTER T
'\u0055',  // U LATIN CAPITAL LETTER U
'\u0056',  // V LATIN CAPITAL LETTER V
'\u0057',  // W LATIN CAPITAL LETTER W
'\u0058',  // X LATIN CAPITAL LETTER X
'\u0059',  // Y LATIN CAPITAL LETTER Y
'\u005A',  // Z LATIN CAPITAL LETTER Z
'\u005B',  // [ LEFT SQUARE BRACKET
'\u005C',  // \ REVERSE SOLIDUS
'\u005D',  // ] RIGHT SQUARE BRACKET
'\u005E',  // ^ CIRCUMFLEX ACCENT
'\u005F',  // _ LOW LINE
'\u0060',  // ` GRAVE ACCENT
'\u0061',  // a LATIN SMALL LETTER A
'\u0062',  // b LATIN SMALL LETTER B
'\u0063',  // c LATIN SMALL LETTER C
'\u0064',  // d LATIN SMALL LETTER D
'\u0065',  // e LATIN SMALL LETTER E
'\u0066',  // f LATIN SMALL LETTER F
'\u0067',  // g LATIN SMALL LETTER G
'\u0068',  // h LATIN SMALL LETTER H
'\u0069',  // i LATIN SMALL LETTER I
'\u006A',  // j LATIN SMALL LETTER J
'\u006B',  // k LATIN SMALL LETTER K
'\u006C',  // l LATIN SMALL LETTER L
'\u006D',  // m LATIN SMALL LETTER M
'\u006E',  // n LATIN SMALL LETTER N
'\u006F',  // o LATIN SMALL LETTER O
'\u0070',  // p LATIN SMALL LETTER P
'\u0071',  // q LATIN SMALL LETTER Q
'\u0072',  // r LATIN SMALL LETTER R
'\u0073',  // s LATIN SMALL LETTER S
'\u0074',  // t LATIN SMALL LETTER T
'\u0075',  // u LATIN SMALL LETTER U
'\u0076',  // v LATIN SMALL LETTER V
'\u0077',  // w LATIN SMALL LETTER W
'\u0078',  // x LATIN SMALL LETTER X
'\u0079',  // y LATIN SMALL LETTER Y
'\u007A',  // z LATIN SMALL LETTER Z
'\u007B',  // { LEFT CURLY BRACKET
'\u00A6',  // ¬¶ BROKEN BAR               CORRECT
'\u007D',  // } RIGHT CURLY BRACKET
'\u007E',  // ~ TILDE
'\u2302',  // ‚åÇ HOUSE                CORRECT
'\u00C7',  // √á LATIN CAPITAL LETTER C WITH CEDILLA
'\u00FC',  // √º LATIN SMALL LETTER U WITH DIAERESIS
'\u00E9',  // √© LATIN SMALL LETTER E WITH ACUTE
'\u00E2',  // √¢ LATIN SMALL LETTER A WITH CIRCUMFLEX
'\u00E4',  // √§ LATIN SMALL LETTER A WITH DIAERESIS
'\u00E0',  // √† LATIN SMALL LETTER A WITH GRAVE
'\u00E5',  // √• LATIN SMALL LETTER A WITH RING ABOVE
'\u00E7',  // √ß LATIN SMALL LETTER C WITH CEDILLA
'\u00EA',  // √™ LATIN SMALL LETTER E WITH CIRCUMFLEX
'\u00EB',  // √´ LATIN SMALL LETTER E WITH DIAERESIS
'\u00E8',  // √® LATIN SMALL LETTER E WITH GRAVE
'\u00EF',  // √Ø LATIN SMALL LETTER I WITH DIAERESIS
'\u00EE',  // √Æ LATIN SMALL LETTER I WITH CIRCUMFLEX
'\u00EC',  // √¨ LATIN SMALL LETTER I WITH GRAVE
'\u00C4',  // √Ñ LATIN CAPITAL LETTER A WITH DIAERESIS
'\u00C5',  // √Ö LATIN CAPITAL LETTER A WITH RING ABOVE
'\u00C9',  // √â LATIN CAPITAL LETTER E WITH ACUTE
'\u00E6',  // √¶ LATIN SMALL LETTER AE
'\u00C6',  // √Ü LATIN CAPITAL LETTER AE
'\u00F4',  // √¥ LATIN SMALL LETTER O WITH CIRCUMFLEX
'\u00F6',  // √∂ LATIN SMALL LETTER O WITH DIAERESIS
'\u00F2',  // √≤ LATIN SMALL LETTER O WITH GRAVE
'\u00FB',  // √ª LATIN SMALL LETTER U WITH CIRCUMFLEX
'\u00F9',  // √π LATIN SMALL LETTER U WITH GRAVE
'\u00FF',  // √ø LATIN SMALL LETTER Y WITH DIAERESIS
'\u00D6',  // √ñ LATIN CAPITAL LETTER O WITH DIAERESIS
'\u00DC',  // √ú LATIN CAPITAL LETTER U WITH DIAERESIS
'\u00A2',  // ¬¢ CENT SIGN
'\u00A3',  // ¬£ POUND SIGN
'\u00A5',  // ¬• YEN SIGN
'\u20A7',  // ‚Çß PESETA SIGN
'\u0192',  // ∆í LATIN SMALL LETTER F WITH HOOK
'\u00E1',  // √° LATIN SMALL LETTER A WITH ACUTE
'\u00ED',  // √≠ LATIN SMALL LETTER I WITH ACUTE
'\u00F3',  // √≥ LATIN SMALL LETTER O WITH ACUTE
'\u00FA',  // √∫ LATIN SMALL LETTER U WITH ACUTE
'\u00F1',  // √± LATIN SMALL LETTER N WITH TILDE
'\u00D1',  // √ë LATIN CAPITAL LETTER N WITH TILDE
'\u00AA',  // ¬™ FEMININE ORDINAL INDICATOR
'\u00BA',  // ¬∫ MASCULINE ORDINAL INDICATOR
'\u00BF',  // ¬ø INVERTED QUESTION MARK
'\u2310',  // ‚åê REVERSED NOT SIGN
'\u00AC',  // ¬¨ NOT SIGN
'\u00BD',  // ¬Ω VULGAR FRACTION ONE HALF
'\u00BC',  // ¬º VULGAR FRACTION ONE QUARTER
'\u00A1',  // ¬° INVERTED EXCLAMATION MARK
'\u00AB',  // ¬´ LEFT-POINTING DOUBLE ANGLE QUOTATION MARK
'\u00BB',  // ¬ª RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK
'\u2591',  // ‚ñë LIGHT SHADE
'\u2592',  // ‚ñí MEDIUM SHADE
'\u2593',  // ‚ñì DARK SHADE
'\u2502',  // ‚îÇ BOX DRAWINGS LIGHT VERTICAL
'\u2524',  // ‚î§ BOX DRAWINGS LIGHT VERTICAL AND LEFT
'\u2561',  // ‚ï° BOX DRAWINGS VERTICAL SINGLE AND LEFT DOUBLE
'\u2562',  // ‚ï¢ BOX DRAWINGS VERTICAL DOUBLE AND LEFT SINGLE
'\u2556',  // ‚ïñ BOX DRAWINGS DOWN DOUBLE AND LEFT SINGLE
'\u2555',  // ‚ïï BOX DRAWINGS DOWN SINGLE AND LEFT DOUBLE
'\u2563',  // ‚ï£ BOX DRAWINGS DOUBLE VERTICAL AND LEFT
'\u2551',  // ‚ïë BOX DRAWINGS DOUBLE VERTICAL
'\u2557',  // ‚ïó BOX DRAWINGS DOUBLE DOWN AND LEFT
'\u255D',  // ‚ïù BOX DRAWINGS DOUBLE UP AND LEFT
'\u255C',  // ‚ïú BOX DRAWINGS UP DOUBLE AND LEFT SINGLE
'\u255B',  // ‚ïõ BOX DRAWINGS UP SINGLE AND LEFT DOUBLE
'\u2510',  // ‚îê BOX DRAWINGS LIGHT DOWN AND LEFT
'\u2514',  // ‚îî BOX DRAWINGS LIGHT UP AND RIGHT
'\u2534',  // ‚î¥ BOX DRAWINGS LIGHT UP AND HORIZONTAL
'\u252C',  // ‚î¨ BOX DRAWINGS LIGHT DOWN AND HORIZONTAL
'\u251C',  // ‚îú BOX DRAWINGS LIGHT VERTICAL AND RIGHT
'\u2500',  // ‚îÄ BOX DRAWINGS LIGHT HORIZONTAL
'\u253C',  // ‚îº BOX DRAWINGS LIGHT VERTICAL AND HORIZONTAL
'\u255E',  // ‚ïû BOX DRAWINGS VERTICAL SINGLE AND RIGHT DOUBLE
'\u255F',  // ‚ïü BOX DRAWINGS VERTICAL DOUBLE AND RIGHT SINGLE
'\u255A',  // ‚ïö BOX DRAWINGS DOUBLE UP AND RIGHT
'\u2554',  // ‚ïî BOX DRAWINGS DOUBLE DOWN AND RIGHT
'\u2569',  // ‚ï© BOX DRAWINGS DOUBLE UP AND HORIZONTAL
'\u2566',  // ‚ï¶ BOX DRAWINGS DOUBLE DOWN AND HORIZONTAL
'\u2560',  // ‚ï† BOX DRAWINGS DOUBLE VERTICAL AND RIGHT
'\u2550',  // ‚ïê BOX DRAWINGS DOUBLE HORIZONTAL
'\u256C',  // ‚ï¨ BOX DRAWINGS DOUBLE VERTICAL AND HORIZONTAL
'\u2567',  // ‚ïß BOX DRAWINGS UP SINGLE AND HORIZONTAL DOUBLE
'\u2568',  // ‚ï® BOX DRAWINGS UP DOUBLE AND HORIZONTAL SINGLE
'\u2564',  // ‚ï§ BOX DRAWINGS DOWN SINGLE AND HORIZONTAL DOUBLE
'\u2565',  // ‚ï• BOX DRAWINGS DOWN DOUBLE AND HORIZONTAL SINGLE
'\u2559',  // ‚ïô BOX DRAWINGS UP DOUBLE AND RIGHT SINGLE
'\u2558',  // ‚ïò BOX DRAWINGS UP SINGLE AND RIGHT DOUBLE
'\u2552',  // ‚ïí BOX DRAWINGS DOWN SINGLE AND RIGHT DOUBLE
'\u2553',  // ‚ïì BOX DRAWINGS DOWN DOUBLE AND RIGHT SINGLE
'\u256B',  // ‚ï´ BOX DRAWINGS VERTICAL DOUBLE AND HORIZONTAL SINGLE
'\u256A',  // ‚ï™ BOX DRAWINGS VERTICAL SINGLE AND HORIZONTAL DOUBLE
'\u2518',  // ‚îò BOX DRAWINGS LIGHT UP AND LEFT
'\u250C',  // ‚îå BOX DRAWINGS LIGHT DOWN AND RIGHT
'\u2588',  // ‚ñà FULL BLOCK
'\u2584',  // ‚ñÑ LOWER HALF BLOCK
'\u258C',  // ‚ñå LEFT HALF BLOCK
'\u2590',  // ‚ñê RIGHT HALF BLOCK
'\u2580',  // ‚ñÄ UPPER HALF BLOCK
'\u03B1',  // Œ± GREEK SMALL LETTER ALPHA     CORRECT
'\u03B2',  // Œ≤ GREEK SMALL LETTER BETA      CORRECT
'\u0393',  // Œì GREEK CAPITAL LETTER GAMMA
'\u03C0',  // œÄ GREEK SMALL LETTER PI
'\u03A3',  // Œ£ GREEK CAPITAL LETTER SIGMA
'\u03C3',  // œÉ GREEK SMALL LETTER SIGMA
'\u03BC',  // Œº GREEK SMALL LETTER MU        CORRECT
'\u03B3',  // Œ≥ GREEK SMALL LETTER GAMMA     CORRECT
'\u03A6',  // Œ¶ GREEK CAPITAL LETTER PHI
'\u03B8',  // Œ∏ GREEK SMALL LETTER THETA     CORRECT
'\u03A9',  // Œ© GREEK CAPITAL LETTER OMEGA       CORRECT
'\u03B4',  // Œ¥ GREEK SMALL LETTER DELTA
'\u221E',  // ‚àû INFINITY
'\u2205',  // ‚àÖ EMPTY SET                CORRECT - BUT NOT WIDELY SUPPORTED
'\u2208',  // ‚àà ELEMENT OF               CORRECT - BUT NOT WIDELY SUPPORTED
'\u2229',  // ‚à© INTERSECTION
'\u2261',  // ‚â° IDENTICAL TO
'\u00B1',  // ¬± PLUS-MINUS SIGN
'\u2265',  // ‚â• GREATER-THAN OR EQUAL TO
'\u2264',  // ‚â§ LESS-THAN OR EQUAL TO
'\u2320',  // ‚å† TOP HALF INTEGRAL
'\u2321',  // ‚å° BOTTOM HALF INTEGRAL
'\u00F7',  // √∑ DIVISION SIGN
'\u2248',  // ‚âà ALMOST EQUAL TO
'\u00B0',  // ¬∞ DEGREE SIGN
'\u2219',  // ‚àô BULLET OPERATOR          CORRECT
'\u22C5',  // ‚ãÖ DOT OPERATOR             CORRECT
'\u221A',  // ‚àö SQUARE ROOT
'\u207F',  // ‚Åø SUPERSCRIPT LATIN SMALL LETTER N
'\u00B2',  // ¬≤ SUPERSCRIPT TWO
'\u220E',  // ‚àé END OF PROOF             CORRECT
'\u00A0',  //   NO-BREAK SPACE
];
}

init();
</script>

</body>
</html>

